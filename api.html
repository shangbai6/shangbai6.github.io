<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>序列预测API</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body>
<script>
    // 获取URL参数
    function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    // 字符转one-hot编码
    function charToOneHot(char) {
        switch(char) {
            case 'A': return [1, 0, 0];
            case 'B': return [0, 1, 0];
            case 'C': return [0, 0, 1];
            default: return [0, 0, 0]; // 无效字符
        }
    }

    // 预处理输入序列
    function preprocessInput(inputString) {
        // 验证输入
        if (!inputString) {
            throw new Error("缺少输入序列参数");
        }
        
        // 检查字符有效性
        if (!/^[ABC]+$/.test(inputString)) {
            throw new Error("输入序列只能包含A、B、C字符");
        }
        
        // 转换为one-hot编码
        const inputArray = [];
        for (let i = 0; i < inputString.length; i++) {
            inputArray.push(charToOneHot(inputString[i]));
        }
        
        return inputArray;
    }

    // 从预测结果中获取字符
    function getCharFromPrediction(prediction) {
        // 获取概率最大的索引
        const maxIndex = prediction.indexOf(Math.max(...prediction));
        return ['A', 'B', 'C'][maxIndex];
    }

    // 主函数
    async function main() {
        try {
            // 获取参数
            const seed = getUrlParameter('seed') || '';
            const length = parseInt(getUrlParameter('length')) || 10;
            const modelPath = getUrlParameter('model') || 'model.json';
            
            // 预处理输入
            const inputArray = preprocessInput(seed);
            
            // 加载模型
            const model = await tf.loadLayersModel(modelPath);
            
            // 准备输入张量
            const inputTensor = tf.tensor([inputArray], [1, inputArray.length, 3]);
            
            // 预测
            const prediction = model.predict(inputTensor);
            
            // 获取最后一个时间步的预测结果
            // 修正维度问题：使用squeeze去除大小为1的维度
            const lastStepPrediction = prediction.slice([0, inputArray.length - 1, 0], [1, 1, 3]).squeeze();
            
            // 转换为数组
            const probabilities = await lastStepPrediction.array();
            
            // 获取预测字符
            const nextChar = getCharFromPrediction(probabilities);
            
            // 生成结果序列
            let result = seed + nextChar;
            
            // 继续生成剩余字符
            for (let i = 1; i < length; i++) {
                // 更新输入数组（移除第一个字符，添加新字符）
                inputArray.shift();
                inputArray.push(charToOneHot(nextChar));
                
                // 重新准备输入张量
                const newInputTensor = tf.tensor([inputArray], [1, inputArray.length, 3]);
                
                // 预测
                const newPrediction = model.predict(newInputTensor);
                
                // 获取最后一个时间步的预测结果
                const newLastStepPrediction = newPrediction.slice([0, inputArray.length - 1, 0], [1, 1, 3]).squeeze();
                
                // 转换为数组
                const newProbabilities = await newLastStepPrediction.array();
                
                // 获取预测字符
                nextChar = getCharFromPrediction(newProbabilities);
                
                // 添加到结果
                result += nextChar;
            }
            
            // 返回成功响应
            const response = {
                status: "success",
                result: result,
                seed: seed,
                length: length,
                model: modelPath,
                timestamp: new Date().toISOString()
            };
            
            // 输出JSON响应
            document.body.innerHTML = `<pre>${JSON.stringify(response, null, 2)}</pre>`;
            
        } catch (error) {
            // 返回错误响应
            const response = {
                status: "error",
                message: error.message,
                timestamp: new Date().toISOString()
            };
            
            // 输出JSON响应
            document.body.innerHTML = `<pre>${JSON.stringify(response, null, 2)}</pre>`;
        }
    }

    // 执行主函数
    main();
</script>
</body>
</html>
