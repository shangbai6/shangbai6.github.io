<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>序列预测API</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body>
<script>
    // 获取URL参数
    function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    // 字符转one-hot编码
    function charToOneHot(char) {
        switch(char) {
            case 'A': return [1, 0, 0];
            case 'B': return [0, 1, 0];
            case 'C': return [0, 0, 1];
            default: throw new Error(`无效字符: ${char}`);
        }
    }

    // one-hot编码转字符
    function oneHotToChar(oneHot) {
        const index = oneHot.indexOf(Math.max(...oneHot));
        return ['A', 'B', 'C'][index];
    }

    // 主函数
    async function main() {
        try {
            // 获取参数
            const seed = getUrlParameter('seed') || 'A';
            const length = parseInt(getUrlParameter('length')) || 5;
            const modelPath = getUrlParameter('model') || 'model.json';
            
            // 验证输入
            if (!/^[ABC]+$/.test(seed)) {
                throw new Error("输入序列只能包含A、B、C字符");
            }
            
            // 加载模型
            const model = await tf.loadLayersModel(modelPath);
            console.log("模型加载成功");
            
            // 生成序列
            let sequence = seed.split('');
            const result = [...sequence];
            
            for (let i = 0; i < length; i++) {
                // 准备输入数据
                const inputArray = sequence.map(char => charToOneHot(char));
                const inputTensor = tf.tensor([inputArray]); // 形状: [1, sequence_length, 3]
                
                // 进行预测
                const prediction = model.predict(inputTensor);
                
                // 检查预测输出的形状
                console.log("预测输出形状:", prediction.shape);
                
                // 处理预测结果
                let predictedChar;
                
                if (prediction.rank === 3) {
                    // 如果输出是3维的 [batch_size, sequence_length, features]
                    // 取最后一个时间步的输出
                    const lastStepOutput = prediction.slice([0, prediction.shape[1]-1, 0], [1, 1, -1]).squeeze();
                    predictedChar = oneHotToChar(Array.from(lastStepOutput.dataSync()));
                } else if (prediction.rank === 2) {
                    // 如果输出是2维的 [batch_size, features]
                    // 直接使用整个输出
                    const output = prediction.squeeze();
                    predictedChar = oneHotToChar(Array.from(output.dataSync()));
                } else {
                    throw new Error(`不支持的预测输出维度: ${prediction.rank}`);
                }
                
                // 添加到结果
                result.push(predictedChar);
                
                // 更新序列（移除第一个字符，添加预测字符）
                sequence.shift();
                sequence.push(predictedChar);
                
                // 释放张量内存
                prediction.dispose();
                inputTensor.dispose();
            }
            
            // 返回结果
            const response = {
                status: "success",
                result: result.join(''),
                seed: seed,
                length: length,
                model: modelPath,
                timestamp: new Date().toISOString()
            };
            
            document.body.innerHTML = `<pre>${JSON.stringify(response, null, 2)}</pre>`;
            
        } catch (error) {
            console.error("错误:", error);
            const response = {
                status: "error",
                message: error.message,
                timestamp: new Date().toISOString()
            };
            document.body.innerHTML = `<pre>${JSON.stringify(response, null, 2)}</pre>`;
        }
    }

    // 执行主函数
    main();
</script>
</body>
</html>
