<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>字符序列预测API</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body>
    <script>
        // 解析URL参数
        function getUrlParams() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const regex = /([^&=]+)=([^&]*)/g;
            let m;
            
            while (m = regex.exec(queryString)) {
                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            
            return params;
        }

        // 字符到数字的映射
        const charToNum = { 'A': 0, 'B': 1, 'C': 2 };
        const numToChar = ['A', 'B', 'C'];

        // 预处理输入序列
        function preprocessInput(inputString, sequenceLength) {
            // 验证输入
            if (!/^[ABC]+$/.test(inputString)) {
                throw new Error("输入序列只能包含A、B、C字符");
            }

            // 转换为数字序列
            let numSequence = inputString.split('').map(char => charToNum[char]);
            
            // 调整数组长度到sequenceLength
            if (numSequence.length > sequenceLength) {
                numSequence = numSequence.slice(0, sequenceLength);
            } else if (numSequence.length < sequenceLength) {
                // 填充0（代表A）到指定长度
                numSequence = numSequence.concat(Array(sequenceLength - numSequence.length).fill(0));
            }

            // 转换为one-hot编码
            const oneHotSequence = numSequence.map(num => {
                const arr = new Array(3).fill(0);
                arr[num] = 1;
                return arr;
            });

            // 创建3D张量 [1, sequenceLength, 3]
            return tf.tensor3d([oneHotSequence], [1, sequenceLength, 3]);
        }

        // 主函数
        async function main() {
            try {
                // 解析URL参数
                const params = getUrlParams();
                const inputString = params.input || '';
                
                if (!inputString) {
                    throw new Error("请提供输入参数，例如: ?input=ABC");
                }

                // 加载模型
                const model = await tf.loadLayersModel('./model.json');
                console.log("模型加载成功");

                // 获取模型输入形状
                const inputShape = model.inputs[0].shape;
                if (inputShape.length !== 3) {
                    throw new Error(`模型输入形状应为3维，但得到的是${inputShape.length}维`);
                }
                
                const sequenceLength = inputShape[1];
                const numFeatures = inputShape[2];

                if (sequenceLength === null) {
                    throw new Error('模型输入形状的第二维（序列长度）为null，无法确定固定长度');
                }
                
                if (numFeatures !== 3) {
                    throw new Error(`模型输入形状的第三维（特征数）应为3，但得到的是${numFeatures}`);
                }

                console.log(`模型期望输入形状: [1, ${sequenceLength}, ${numFeatures}]`);

                // 预处理输入
                const inputTensor = preprocessInput(inputString, sequenceLength);
                console.log("输入张量形状:", inputTensor.shape);

                // 进行预测
                const prediction = model.predict(inputTensor);
                const predictionData = await prediction.data();
                
                // 找到概率最高的字符
                let maxProb = -1;
                let predictedIndex = -1;
                for (let i = 0; i < predictionData.length; i++) {
                    if (predictionData[i] > maxProb) {
                        maxProb = predictionData[i];
                        predictedIndex = i;
                    }
                }
                
                const predictedChar = numToChar[predictedIndex];

                // 输出结果
                const result = {
                    status: "success",
                    input: inputString,
                    sequenceLength: sequenceLength,
                    prediction: predictedChar,
                    probabilities: {
                        'A': predictionData[0],
                        'B': predictionData[1],
                        'C': predictionData[2]
                    },
                    timestamp: new Date().toISOString()
                };
                
                document.body.innerText = JSON.stringify(result, null, 2);
                
                // 释放内存
                inputTensor.dispose();
                prediction.dispose();
                
            } catch (error) {
                const errorResult = {
                    status: "error",
                    message: error.message,
                    timestamp: new Date().toISOString()
                };
                document.body.innerText = JSON.stringify(errorResult, null, 2);
                console.error("预测失败:", error);
            }
        }

        // 执行主函数
        main();
    </script>
</body>
</html>
