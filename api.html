<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>序列预测API</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body>
<script>
    // 获取URL参数
    function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    // 字符转one-hot编码
    function charToOneHot(char) {
        switch(char) {
            case 'A': return [1, 0, 0];
            case 'B': return [0, 1, 0];
            case 'C': return [0, 0, 1];
            default: return [0, 0, 0]; // 无效字符
        }
    }

    // 将索引转换为字符
    function indexToChar(index) {
        const chars = ['A', 'B', 'C'];
        return chars[index] || '';
    }

    // 预处理输入序列
    function preprocessInput(inputString) {
        // 验证输入
        if (!inputString || !/^[ABC]+$/.test(inputString)) {
            throw new Error('输入序列只能包含A、B、C字符');
        }
        
        // 转换为one-hot编码
        const oneHotArray = [];
        for (let i = 0; i < inputString.length; i++) {
            oneHotArray.push(charToOneHot(inputString[i]));
        }
        
        // 创建张量 [batch_size=1, sequence_length, features=3]
        return tf.tensor([oneHotArray]);
    }

    // 主函数
    (async function() {
        try {
            // 获取参数
            const modelPath = getUrlParameter('model') || 'model.json';
            const seed = getUrlParameter('seed');
            const length = parseInt(getUrlParameter('length')) || 10;
            
            // 验证参数
            if (!seed) {
                throw new Error('缺少必需参数: seed');
            }
            if (isNaN(length) || length <= 0) {
                throw new Error('参数length必须是正整数');
            }
            
            // 加载模型
            console.log('正在加载模型:', modelPath);
            const model = await tf.loadLayersModel(modelPath);
            console.log('模型加载成功');
            
            // 预处理输入
            const inputTensor = preprocessInput(seed);
            
            // 生成序列
            let generatedSequence = seed;
            let currentSequence = seed;
            
            for (let i = 0; i < length; i++) {
                // 预测下一个字符
                const prediction = model.predict(inputTensor);
                const lastStepPrediction = prediction.slice([0, currentSequence.length-1, 0], [1, 1, 3]).reshape([3]);
                const predictedIndex = lastStepPrediction.argMax().dataSync()[0];
                const predictedChar = indexToChar(predictedIndex);
                
                // 添加到生成序列
                generatedSequence += predictedChar;
                
                // 更新当前序列（移除第一个字符，添加新字符）
                currentSequence = currentSequence.substring(1) + predictedChar;
                
                // 更新输入张量
                inputTensor.dispose();
                const newInput = [];
                for (let j = 0; j < currentSequence.length; j++) {
                    newInput.push(charToOneHot(currentSequence[j]));
                }
                inputTensor = tf.tensor([newInput]);
                
                // 释放内存
                prediction.dispose();
                lastStepPrediction.dispose();
            }
            
            // 释放资源
            model.dispose();
            inputTensor.dispose();
            
            // 返回结果
            const result = {
                status: "success",
                result: generatedSequence,
                seed: seed,
                length: length,
                model: modelPath,
                timestamp: new Date().toISOString()
            };
            
            document.write(JSON.stringify(result, null, 2));
            
        } catch (error) {
            // 错误处理
            const errorResult = {
                status: "error",
                message: error.message,
                timestamp: new Date().toISOString()
            };
            
            document.write(JSON.stringify(errorResult, null, 2));
        }
    })();
</script>
</body>
</html>
