<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>字符序列预测API</title>
 <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
</head>
<body>
 <script>
 // --- 全局变量和常量 ---
 const charToIndex = {'A': 0, 'B': 1, 'C': 2}; // 根据实际字符集调整
 const indexToChar = {0: 'A', 1: 'B', 2: 'C'}; // 根据实际字符集调整
 const VOCAB_SIZE = 3;
 const PADDING_CHAR = 'A';
 let model = null;
 let loadedModelSequenceLength = 0;

 // 解析URL参数
 function getUrlParams() {
   const params = {};
   window.location.search.substring(1).split('&').forEach(param => {
     const keyValue = param.split('=');
     if (keyValue[0]) params[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1]) || '';
   });
   return params;
 }

 // 准备输入序列
 function prepareInputSequence(rawSeedSequence) {
   // 根据模型需求处理输入序列
   return rawSeedSequence.padEnd(loadedModelSequenceLength, PADDING_CHAR);
 }

 // 生成序列
 async function generateSequence(seedSequence, generateLength) {
   const inputSequence = prepareInputSequence(seedSequence);
   let generatedSequence = seedSequence;
   for (let i = 0; i < generateLength; i++) {
     const inputTensor = tf.tensor([inputSequence.split('').map(c => charToIndex[c])]);
     const prediction = model.predict(inputTensor);
     const predictedCharIndex = tf.argMax(prediction, 1).dataSync()[0];
     const predictedChar = indexToChar[predictedCharIndex];
     generatedSequence += predictedChar;
     inputSequence.shift(); // 移除第一个字符
     inputSequence.push(predictedChar); // 添加新预测的字符
   }
   return generatedSequence;
 }

 // 加载模型
 async function loadModel() {
   model = await tf.loadLayersModel('path/to/model.json');
   // 假设模型序列长度存储在模型的某个属性中，需要根据实际情况获取
   loadedModelSequenceLength = model.sequenceLength || 4; // 示例值，根据实际情况调整
 }

 // 主函数
 async function main() {
   const params = getUrlParams();
   if (!params.sequence) {
     document.body.textContent = JSON.stringify({
       "error": true,
       "message": "缺少必需参数: sequence",
       "code": 400,
       "timestamp": new Date().toISOString()
     });
     return;
   }

   const rawSeedSequence = params.sequence;
   const generateLength = parseInt(params.length, 10) || 10; // 默认生成长度为10

   if (generateLength < 1 || generateLength > 200) {
     document.body.textContent = JSON.stringify({
       "error": true,
       "message": "生成长度必须在1到200之间",
       "code": 400,
       "timestamp": new Date().toISOString()
     });
     return;
   }

   await loadModel();

   try {
     const generatedSequence = await generateSequence(rawSeedSequence, generateLength);
     document.body.textContent = JSON.stringify({
       "inputSequence": rawSeedSequence,
       "processedSequence": prepareInputSequence(rawSeedSequence),
       "generatedSequence": generatedSequence,
       "generatedLength": generateLength,
       "modelSequenceLength": loadedModelSequenceLength,
       "timestamp": new Date().toISOString()
     });
   } catch (error) {
     document.body.textContent = JSON.stringify({
       "error": true,
       "message": error.message,
       "code": 500,
       "timestamp": new Date().toISOString()
     });
   }
 }

 main();
 </script>
</body>
</html>
