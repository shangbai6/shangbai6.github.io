import React, { useState, useEffect } from 'react';
import { Swords, Shield, Heart, Zap, Brain, Target, Book, Music } from 'lucide-react';

// å‘½é€”å®šä¹‰
const PATHS = {
  destruction: { name: 'æ¯ç­', icon: Swords, color: 'text-red-600', bg: 'bg-red-100', desc: 'é€ æˆ3ç‚¹ä¼¤å®³' },
  preservation: { name: 'å­˜æŠ¤', icon: Shield, color: 'text-blue-600', bg: 'bg-blue-100', desc: 'è·å¾—5ç‚¹æŠ¤ç›¾' },
  abundance: { name: 'ä¸°é¥¶', icon: Heart, color: 'text-green-600', bg: 'bg-green-100', desc: 'æ¢å¤4ç‚¹ç”Ÿå‘½' },
  nihility: { name: 'è™šæ— ', icon: Zap, color: 'text-purple-600', bg: 'bg-purple-100', desc: 'å¯¹æ‰‹å¤±å»1ç‚¹å‘½é€”è¿›åº¦' },
  erudition: { name: 'æ™ºè¯†', icon: Brain, color: 'text-yellow-600', bg: 'bg-yellow-100', desc: 'æŠ½2å¼ ç‰Œ' },
  hunt: { name: 'å·¡çŒ', icon: Target, color: 'text-orange-600', bg: 'bg-orange-100', desc: 'é€ æˆ2ç‚¹ä¼¤å®³ä¸¤æ¬¡' },
  remembrance: { name: 'è®°å¿†', icon: Book, color: 'text-indigo-600', bg: 'bg-indigo-100', desc: 'ä»å¼ƒç‰Œå †å›æ”¶1å¼ ç‰Œ' },
  harmony: { name: 'åŒè°', icon: Music, color: 'text-pink-600', bg: 'bg-pink-100', desc: 'æ‰€æœ‰å‘½é€”+1è¿›åº¦' }
};

// å¡ç‰Œç­‰çº§
const CARD_RANKS = {
  walker: { name: 'å‘½é€”è¡Œè€…', power: 1, color: 'border-gray-400' },
  emanator: { name: 'ä»¤ä½¿', power: 2, color: 'border-purple-500' },
  aeon: { name: 'æ˜Ÿç¥', power: 3, color: 'border-yellow-500' }
};

const Game = () => {
  const [gameState, setGameState] = useState('select'); // select, playing, end
  const [selectedPath, setSelectedPath] = useState(null);
  const [player, setPlayer] = useState({ hp: 30, shield: 0, paths: {}, hand: [], deck: [], discard: [] });
  const [enemy, setEnemy] = useState({ hp: 30, shield: 0, paths: {}, hand: [], deck: [], discard: [] });
  const [turn, setTurn] = useState('player');
  const [message, setMessage] = useState('');
  const [winner, setWinner] = useState(null);

  // åˆå§‹åŒ–ç‰Œç»„
  const initDeck = () => {
    const deck = [];
    const pathKeys = Object.keys(PATHS);
    
    // æ¯ä¸ªå‘½é€”å„3å¼ ä¸åŒç­‰çº§çš„ç‰Œ
    pathKeys.forEach(path => {
      deck.push({ path, rank: 'aeon', id: Math.random() });
      deck.push({ path, rank: 'emanator', id: Math.random() });
      deck.push({ path, rank: 'emanator', id: Math.random() });
      deck.push({ path, rank: 'walker', id: Math.random() });
      deck.push({ path, rank: 'walker', id: Math.random() });
    });
    
    return deck.sort(() => Math.random() - 0.5);
  };

  // æŠ½ç‰Œ
  const drawCard = (playerState) => {
    if (playerState.deck.length === 0) {
      if (playerState.discard.length === 0) return playerState;
      playerState.deck = [...playerState.discard].sort(() => Math.random() - 0.5);
      playerState.discard = [];
    }
    
    const card = playerState.deck.pop();
    playerState.hand.push(card);
    return { ...playerState };
  };

  // å¼€å§‹æ¸¸æˆ
  const startGame = (path) => {
    setSelectedPath(path);
    
    const playerDeck = initDeck();
    const enemyDeck = initDeck();
    
    let newPlayer = { 
      hp: 30, 
      shield: 0, 
      paths: Object.keys(PATHS).reduce((acc, p) => ({ ...acc, [p]: 0 }), {}),
      hand: [],
      deck: playerDeck,
      discard: []
    };
    
    let newEnemy = { 
      hp: 30, 
      shield: 0, 
      paths: Object.keys(PATHS).reduce((acc, p) => ({ ...acc, [p]: 0 }), {}),
      hand: [],
      deck: enemyDeck,
      discard: []
    };
    
    // åˆå§‹æŠ½ç‰Œ
    for (let i = 0; i < 5; i++) {
      newPlayer = drawCard(newPlayer);
      newEnemy = drawCard(newEnemy);
    }
    
    setPlayer(newPlayer);
    setEnemy(newEnemy);
    setGameState('playing');
    setMessage('æ¸¸æˆå¼€å§‹ï¼é€‰æ‹©ä¸€å¼ å¡ç‰Œæ‰“å‡ºã€‚');
  };

  // æ‰“å‡ºå¡ç‰Œ
  const playCard = (card, isPlayer = true) => {
    const current = isPlayer ? player : enemy;
    const newState = { ...current };
    
    // ç§»é™¤æ‰‹ç‰Œ
    newState.hand = newState.hand.filter(c => c.id !== card.id);
    newState.discard.push(card);
    
    // å¢åŠ å‘½é€”è¿›åº¦
    const power = CARD_RANKS[card.rank].power;
    newState.paths[card.path] = (newState.paths[card.path] || 0) + power;
    
    if (isPlayer) {
      setPlayer(newState);
      setMessage(`ä½ æ‰“å‡ºäº†${PATHS[card.path].name}çš„${CARD_RANKS[card.rank].name}ï¼Œè·å¾—${power}ç‚¹${PATHS[card.path].name}è¿›åº¦ï¼`);
    } else {
      setEnemy(newState);
    }
    
    return newState;
  };

  // ä½¿ç”¨å‘½é€”èƒ½åŠ›
  const usePathAbility = (path, isPlayer = true) => {
    const current = isPlayer ? player : enemy;
    const target = isPlayer ? enemy : player;
    
    if (current.paths[path] < 3) {
      if (isPlayer) setMessage('å‘½é€”è¿›åº¦ä¸è¶³ï¼éœ€è¦è‡³å°‘3ç‚¹è¿›åº¦æ‰èƒ½ä½¿ç”¨èƒ½åŠ›ã€‚');
      return;
    }
    
    let newCurrent = { ...current };
    let newTarget = { ...target };
    newCurrent.paths[path] -= 3;
    
    let msg = '';
    
    switch(path) {
      case 'destruction':
        const dmg1 = Math.max(0, 3 - newTarget.shield);
        newTarget.shield = Math.max(0, newTarget.shield - 3);
        newTarget.hp -= dmg1;
        msg = `é€ æˆäº†3ç‚¹ä¼¤å®³ï¼`;
        break;
        
      case 'preservation':
        newCurrent.shield += 5;
        msg = `è·å¾—äº†5ç‚¹æŠ¤ç›¾ï¼`;
        break;
        
      case 'abundance':
        newCurrent.hp = Math.min(30, newCurrent.hp + 4);
        msg = `æ¢å¤äº†4ç‚¹ç”Ÿå‘½ï¼`;
        break;
        
      case 'nihility':
        const pathKeys = Object.keys(newTarget.paths);
        const randomPath = pathKeys[Math.floor(Math.random() * pathKeys.length)];
        newTarget.paths[randomPath] = Math.max(0, newTarget.paths[randomPath] - 1);
        msg = `å‰Šå¼±äº†å¯¹æ‰‹çš„${PATHS[randomPath].name}è¿›åº¦ï¼`;
        break;
        
      case 'erudition':
        newCurrent = drawCard(newCurrent);
        newCurrent = drawCard(newCurrent);
        msg = `æŠ½å–äº†2å¼ ç‰Œï¼`;
        break;
        
      case 'hunt':
        const dmg2a = Math.max(0, 2 - newTarget.shield);
        newTarget.shield = Math.max(0, newTarget.shield - 2);
        newTarget.hp -= dmg2a;
        const dmg2b = Math.max(0, 2 - newTarget.shield);
        newTarget.shield = Math.max(0, newTarget.shield - 2);
        newTarget.hp -= dmg2b;
        msg = `è¿ç»­é€ æˆäº†2æ¬¡2ç‚¹ä¼¤å®³ï¼`;
        break;
        
      case 'remembrance':
        if (newCurrent.discard.length > 0) {
          const recovered = newCurrent.discard.pop();
          newCurrent.hand.push(recovered);
          msg = `ä»å¼ƒç‰Œå †å›æ”¶äº†1å¼ ç‰Œï¼`;
        } else {
          msg = `å¼ƒç‰Œå †ä¸ºç©ºï¼Œæ— æ³•å›æ”¶ï¼`;
        }
        break;
        
      case 'harmony':
        Object.keys(newCurrent.paths).forEach(p => {
          newCurrent.paths[p] += 1;
        });
        msg = `æ‰€æœ‰å‘½é€”è¿›åº¦+1ï¼`;
        break;
    }
    
    if (isPlayer) {
      setPlayer(newCurrent);
      setEnemy(newTarget);
      setMessage(msg);
      
      // æ£€æŸ¥èƒœè´Ÿ
      if (newTarget.hp <= 0) {
        setWinner('player');
        setGameState('end');
        return;
      }
      
      // å›åˆç»“æŸ
      setTimeout(() => {
        setTurn('enemy');
      }, 1000);
    } else {
      setEnemy(newCurrent);
      setPlayer(newTarget);
      
      // æ£€æŸ¥èƒœè´Ÿ
      if (newTarget.hp <= 0) {
        setWinner('enemy');
        setGameState('end');
        return;
      }
    }
  };

  // AIå›åˆ
  useEffect(() => {
    if (gameState === 'playing' && turn === 'enemy') {
      setTimeout(() => {
        let newEnemy = { ...enemy };
        
        // AIæ‰“å‡ºä¸€å¼ ç‰Œ
        if (newEnemy.hand.length > 0) {
          const card = newEnemy.hand[Math.floor(Math.random() * newEnemy.hand.length)];
          newEnemy = playCard(card, false);
        }
        
        // AIéšæœºä½¿ç”¨ä¸€ä¸ªèƒ½åŠ›ï¼ˆå¦‚æœæœ‰è¶³å¤Ÿè¿›åº¦ï¼‰
        const availablePaths = Object.keys(newEnemy.paths).filter(p => newEnemy.paths[p] >= 3);
        if (availablePaths.length > 0 && Math.random() > 0.3) {
          const chosenPath = availablePaths[Math.floor(Math.random() * availablePaths.length)];
          setTimeout(() => {
            usePathAbility(chosenPath, false);
            
            // æŠ½ç‰Œ
            setTimeout(() => {
              let finalEnemy = { ...enemy };
              finalEnemy = drawCard(finalEnemy);
              setEnemy(finalEnemy);
              setTurn('player');
              setMessage('ä½ çš„å›åˆï¼');
            }, 1000);
          }, 1000);
        } else {
          // æŠ½ç‰Œ
          setTimeout(() => {
            newEnemy = drawCard(newEnemy);
            setEnemy(newEnemy);
            setTurn('player');
            setMessage('ä½ çš„å›åˆï¼');
          }, 1000);
        }
      }, 1000);
    }
  }, [turn, gameState]);

  // ç©å®¶ç»“æŸå›åˆ
  const endTurn = () => {
    if (turn !== 'player') return;
    
    let newPlayer = drawCard({ ...player });
    setPlayer(newPlayer);
    setTurn('enemy');
    setMessage('æ•Œäººçš„å›åˆ...');
  };

  if (gameState === 'select') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-8">
        <div className="max-w-6xl mx-auto">
          <h1 className="text-5xl font-bold text-center text-white mb-4">å‘½é€”ä¹‹äº‰</h1>
          <p className="text-center text-gray-300 mb-8">é€‰æ‹©ä½ çš„ä¸»å‘½é€”ï¼Œè¸ä¸Šæ˜Ÿç©¹ä¹‹æ—…</p>
          
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {Object.entries(PATHS).map(([key, path]) => {
              const Icon = path.icon;
              return (
                <button
                  key={key}
                  onClick={() => startGame(key)}
                  className="bg-white/10 backdrop-blur-sm border-2 border-white/20 rounded-xl p-6 hover:bg-white/20 hover:scale-105 transition-all"
                >
                  <Icon className={`w-12 h-12 mx-auto mb-3 ${path.color}`} />
                  <h3 className="text-xl font-bold text-white mb-2">{path.name}</h3>
                  <p className="text-sm text-gray-300">{path.desc}</p>
                </button>
              );
            })}
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'end') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-8 flex items-center justify-center">
        <div className="bg-white/10 backdrop-blur-sm border-2 border-white/20 rounded-xl p-12 text-center">
          <h2 className="text-5xl font-bold text-white mb-4">
            {winner === 'player' ? 'èƒœåˆ©ï¼' : 'è´¥åŒ—...'}
          </h2>
          <p className="text-2xl text-gray-300 mb-8">
            {winner === 'player' ? 'ä½ æˆåŠŸå‡»è´¥äº†å¯¹æ‰‹ï¼' : 'ç»§ç»­ä¿®è¡Œï¼Œå†æ¬¡æŒ‘æˆ˜å§ï¼'}
          </p>
          <button
            onClick={() => {
              setGameState('select');
              setWinner(null);
            }}
            className="bg-purple-600 hover:bg-purple-700 text-white px-8 py-3 rounded-lg font-bold text-lg"
          >
            å†æ¥ä¸€å±€
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 p-4">
      <div className="max-w-7xl mx-auto">
        {/* æ•ŒäººçŠ¶æ€ */}
        <div className="bg-red-900/30 backdrop-blur-sm border-2 border-red-500/50 rounded-xl p-4 mb-4">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-xl font-bold text-white">æ•Œäºº</h3>
            <div className="flex gap-4">
              <div className="text-white">â¤ï¸ {enemy.hp}/30</div>
              <div className="text-blue-300">ğŸ›¡ï¸ {enemy.shield}</div>
            </div>
          </div>
          <div className="flex gap-2 flex-wrap">
            {Object.entries(enemy.paths).map(([key, value]) => (
              value > 0 && (
                <div key={key} className={`px-2 py-1 rounded ${PATHS[key].bg} text-xs font-bold`}>
                  {PATHS[key].name}: {value}
                </div>
              )
            ))}
          </div>
        </div>

        {/* æ¶ˆæ¯ */}
        <div className="bg-white/10 backdrop-blur-sm border-2 border-white/20 rounded-xl p-3 mb-4 text-center text-white">
          {message}
        </div>

        {/* ç©å®¶æ‰‹ç‰Œ */}
        <div className="bg-white/10 backdrop-blur-sm border-2 border-white/20 rounded-xl p-4 mb-4">
          <h3 className="text-lg font-bold text-white mb-3">ä½ çš„æ‰‹ç‰Œ</h3>
          <div className="grid grid-cols-5 gap-2">
            {player.hand.map(card => {
              const path = PATHS[card.path];
              const rank = CARD_RANKS[card.rank];
              const Icon = path.icon;
              return (
                <button
                  key={card.id}
                  onClick={() => turn === 'player' && playCard(card)}
                  disabled={turn !== 'player'}
                  className={`bg-white border-4 ${rank.color} rounded-lg p-3 hover:scale-105 transition-all disabled:opacity-50 disabled:hover:scale-100`}
                >
                  <Icon className={`w-8 h-8 mx-auto mb-1 ${path.color}`} />
                  <div className="text-xs font-bold text-gray-800">{path.name}</div>
                  <div className="text-xs text-gray-600">{rank.name}</div>
                  <div className="text-lg font-bold text-purple-600">+{rank.power}</div>
                </button>
              );
            })}
          </div>
        </div>

        {/* ç©å®¶çŠ¶æ€å’Œèƒ½åŠ› */}
        <div className="bg-blue-900/30 backdrop-blur-sm border-2 border-blue-500/50 rounded-xl p-4">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-xl font-bold text-white">ä½ </h3>
            <div className="flex gap-4">
              <div className="text-white">â¤ï¸ {player.hp}/30</div>
              <div className="text-blue-300">ğŸ›¡ï¸ {player.shield}</div>
              <button
                onClick={endTurn}
                disabled={turn !== 'player'}
                className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 text-white px-4 py-1 rounded font-bold"
              >
                ç»“æŸå›åˆ
              </button>
            </div>
          </div>
          
          <div className="grid grid-cols-4 gap-2">
            {Object.entries(PATHS).map(([key, path]) => {
              const Icon = path.icon;
              const progress = player.paths[key] || 0;
              const canUse = progress >= 3 && turn === 'player';
              return (
                <button
                  key={key}
                  onClick={() => canUse && usePathAbility(key)}
                  disabled={!canUse}
                  className={`${path.bg} border-2 border-gray-300 rounded-lg p-2 hover:scale-105 transition-all disabled:opacity-50 disabled:hover:scale-100`}
                >
                  <Icon className={`w-6 h-6 mx-auto mb-1 ${path.color}`} />
                  <div className="text-xs font-bold text-gray-800">{path.name}</div>
                  <div className="text-lg font-bold text-purple-600">{progress}</div>
                  <div className="text-xs text-gray-600">éœ€è¦3ç‚¹</div>
                </button>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Game;
