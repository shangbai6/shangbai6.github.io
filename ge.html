<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋 AI (Gomoku AI) - Single File</title>
    <style>
        /* CSS styles go here */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 20px 0; /* Add some margin top/bottom */
            padding: 0 10px; /* Add side padding for smaller screens */
            box-sizing: border-box;
        }

        .container {
            text-align: center;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 95%; /* Prevent overflow on very small screens */
        }

        h1 {
            color: #333;
            margin-top: 0;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            align-items: center;
            gap: 10px 15px; /* Row gap, Column gap */
        }

        .controls label {
            font-weight: bold;
            white-space: nowrap; /* Prevent label breaking */
        }

        .controls input[type="number"] {
            width: 50px;
            padding: 5px;
            text-align: center;
            font-size: 1em;
        }

        .controls button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        .controls span {
            font-size: 0.8em;
            color: #666;
            flex-basis: 100%; /* Make hint take full width if wrapped */
            text-align: center;
            margin-top: 5px;
        }


        #board {
            display: grid;
            /* Grid size set by JS */
            border: 2px solid #555;
            margin: 20px auto; /* Center the board */
            position: relative;
            background-color: #e4b26a; /* Wooden board color */
            /* Max width/height to prevent excessive size */
            max-width: 100%;
            max-height: 70vh; /* Limit height relative to viewport */
            aspect-ratio: 1 / 1; /* Maintain square shape */
            /* Grid will be dynamically sized by JS */
        }

        .cell {
            /* Width/Height set by JS */
            border: 1px solid #999; /* Grid lines */
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .cell:hover:not(:has(.piece)) { /* Only hover empty cells */
             background-color: rgba(0, 0, 0, 0.1); /* Slight hover effect */
        }

        .piece {
            width: 80%; /* Relative to cell size */
            height: 80%; /* Relative to cell size */
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4);
            position: absolute; /* Ensure centering within cell */
            top: 10%;
            left: 10%;
        }

        .black {
            background: radial-gradient(circle at 30% 30%, #555, #000);
        }

        .white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
        }

        #status {
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #d9534f; /* Default to red-ish */
            min-height: 1.5em; /* Prevent layout shift */
        }

         /* Style for disabled state */
        #board.disabled {
            pointer-events: none;
            opacity: 0.8;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>五子棋 AI 对战</h1>

        <div class="controls">
            <label for="depth">AI 搜索深度 (Depth):</label>
            <input type="number" id="depth" value="2" min="1" max="5">
            <button id="resetBtn">重新开始 (Reset)</button>
            <span>(推荐 1-3，更高深度可能很慢)</span>
        </div>

        <div id="board">
            <!-- Board cells will be generated by JavaScript -->
        </div>

        <div id="status">正在初始化...</div>
    </div>

    <script>
        // JavaScript logic goes here
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('board');
            const statusElement = document.getElementById('status');
            const depthInput = document.getElementById('depth');
            const resetBtn = document.getElementById('resetBtn');

            const BOARD_SIZE = 15;
            // CELL_SIZE will be calculated dynamically
            const EMPTY = 0;
            const BLACK = 1; // Player
            const WHITE = 2; // AI

            let board = [];
            let currentPlayer = BLACK;
            let gameOver = false;
            let aiSearchDepth = parseInt(depthInput.value) || 2;
            let cellSize = 30; // Default, will be recalculated

            // --- Initialization ---

            function calculateCellSize() {
                 const containerWidth = boardElement.offsetWidth;
                 // Subtract border width (left+right)
                 const boardAreaWidth = containerWidth - 4; // 2px border * 2
                 cellSize = Math.floor(boardAreaWidth / BOARD_SIZE);
                 // Ensure minimum cell size? Maybe not needed if container is sized well.
                 // cellSize = Math.max(20, cellSize); // Example minimum
                 return cellSize;
            }

            function initBoard() {
                board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
                currentPlayer = BLACK;
                gameOver = false;
                aiSearchDepth = parseInt(depthInput.value) || 2;
                drawBoard(); // Draw board will recalculate sizes
                updateStatus("轮到你了 (黑棋)");
                boardElement.classList.remove('disabled'); // Ensure board is clickable
            }

            function drawBoard() {
                cellSize = calculateCellSize(); // Recalculate based on current container size
                const boardPixelSize = cellSize * BOARD_SIZE;

                boardElement.innerHTML = ''; // Clear previous board
                boardElement.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, ${cellSize}px)`;
                boardElement.style.gridTemplateRows = `repeat(${BOARD_SIZE}, ${cellSize}px)`;
                // Set explicit width/height based on calculated cell size to ensure grid lines match
                boardElement.style.width = `${boardPixelSize}px`;
                boardElement.style.height = `${boardPixelSize}px`;


                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.style.width = `${cellSize}px`;
                        cell.style.height = `${cellSize}px`;


                        if (board[r][c] !== EMPTY) {
                            const piece = document.createElement('div');
                            piece.classList.add('piece');
                            piece.classList.add(board[r][c] === BLACK ? 'black' : 'white');
                            cell.appendChild(piece);
                            cell.style.cursor = 'not-allowed';
                        } else if (!gameOver) { // Only add listener if game is active
                            cell.addEventListener('click', handleCellClick);
                            cell.style.cursor = 'pointer';
                        } else {
                             cell.style.cursor = 'not-allowed'; // Game over
                        }
                        boardElement.appendChild(cell);
                    }
                }
            }

            // --- Game Logic ---

            function handleCellClick(event) {
                // Allow click only if it's player's turn, game not over, and it's directly on the cell (not the piece div)
                if (gameOver || currentPlayer === WHITE || !event.target.classList.contains('cell')) return;

                // Check if cell already has a piece (shouldn't happen with event listener logic, but safe check)
                 if (event.target.querySelector('.piece')) {
                     return;
                 }


                const row = parseInt(event.target.dataset.row);
                const col = parseInt(event.target.dataset.col);

                // Check internal board state again for safety
                if (board[row][col] === EMPTY) {
                    placePiece(row, col, BLACK, event.target); // Pass cell element

                    if (checkWin(row, col, BLACK)) {
                        endGame("你赢了！(黑棋获胜)");
                    } else if (checkDraw()) {
                        endGame("平局！");
                    } else {
                        switchPlayer();
                        // Use setTimeout to allow UI update before AI starts thinking
                        setTimeout(makeAiMove, 100);
                    }
                }
            }

            function placePiece(row, col, player, cellElement = null) {
                 if (board[row][col] !== EMPTY) return; // Prevent overwriting

                 board[row][col] = player;

                 // Update visual board
                 const cell = cellElement || boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                 if (cell) {
                     // Ensure no piece exists before adding
                     if (!cell.querySelector('.piece')) {
                         const piece = document.createElement('div');
                         piece.classList.add('piece');
                         piece.classList.add(player === BLACK ? 'black' : 'white');
                         cell.appendChild(piece);
                     }
                     cell.style.cursor = 'not-allowed';
                     // Remove click listener if it exists (important for player moves)
                     cell.removeEventListener('click', handleCellClick);
                 }
             }

             // Used by the AI simulation - does NOT update visuals for speed
             function simulatePlacePiece(row, col, player) {
                 board[row][col] = player;
             }

             function simulateRemovePiece(row, col) {
                 board[row][col] = EMPTY;
             }


            function switchPlayer() {
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
                updateStatus(currentPlayer === BLACK ? "轮到你了 (黑棋)" : "AI 正在思考... (白棋)");
            }

            function updateStatus(message) {
                statusElement.textContent = message;
                if (message.includes("赢了")) {
                    statusElement.style.color = 'green';
                } else if (message.includes("平局")) {
                    statusElement.style.color = 'orange';
                } else if (message.includes("轮到你了")) {
                     statusElement.style.color = '#d9534f'; // Red-ish for player
                } else if (message.includes("AI 正在思考")) {
                    statusElement.style.color = '#0275d8'; // Blue-ish for AI
                } else {
                     statusElement.style.color = '#666'; // Default/neutral
                }
            }

            function endGame(message) {
                gameOver = true;
                updateStatus(message);
                // Make board visually non-interactive
                boardElement.classList.add('disabled');
                // Remove listeners and change cursors on any remaining empty cells
                boardElement.querySelectorAll('.cell').forEach(cell => {
                     if (!cell.querySelector('.piece')) {
                         cell.removeEventListener('click', handleCellClick);
                         cell.style.cursor = 'not-allowed';
                     }
                 });
            }


            // --- Win/Draw Check ---

            function checkWin(row, col, player) {
                const directions = [
                    [0, 1],  // Horizontal -->
                    [1, 0],  // Vertical   \/
                    [1, 1],  // Diagonal   \
                    [1, -1] // Diagonal   /
                ];

                for (const [dr, dc] of directions) {
                    let count = 1; // Count the piece just placed

                    // Check in one direction (+)
                    for (let i = 1; i < 5; i++) {
                        const nr = row + dr * i;
                        const nc = col + dc * i;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }

                    // Check in the opposite direction (-)
                    for (let i = 1; i < 5; i++) {
                        const nr = row - dr * i;
                        const nc = col - dc * i;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }

                    if (count >= 5) {
                        return true;
                    }
                }
                return false;
            }

            function checkDraw() {
                // Check if any empty cells remain
                 for (let r = 0; r < BOARD_SIZE; r++) {
                     for (let c = 0; c < BOARD_SIZE; c++) {
                         if (board[r][c] === EMPTY) {
                             return false; // Found empty cell, not a draw
                         }
                     }
                 }
                 // No empty cells found, and no winner yet (checked before calling checkDraw)
                 return true;
            }

            // --- AI Logic ---

            function makeAiMove() {
                if (gameOver) return;
                updateStatus("AI 正在思考... (白棋)");
                boardElement.classList.add('disabled'); // Disable clicks during AI turn


                // Use setTimeout to ensure the "Thinking..." message is displayed
                // and give browser slight pause before potentially heavy computation
                setTimeout(() => {
                    console.time(`AI Depth ${aiSearchDepth}`);
                    const bestMove = findBestMove(aiSearchDepth);
                    console.timeEnd(`AI Depth ${aiSearchDepth}`);


                    if (bestMove) {
                        // Find the cell element *before* placing the piece visually
                        const cellElement = boardElement.querySelector(`[data-row="${bestMove.row}"][data-col="${bestMove.col}"]`);
                        placePiece(bestMove.row, bestMove.col, WHITE, cellElement);

                        if (checkWin(bestMove.row, bestMove.col, WHITE)) {
                            endGame("AI 赢了！(白棋获胜)");
                            // Keep board disabled on game end
                        } else if (checkDraw()) {
                            endGame("平局！");
                            // Keep board disabled on game end
                        } else {
                            switchPlayer();
                            boardElement.classList.remove('disabled'); // Re-enable clicks for player
                        }
                    } else {
                        // This case should ideally only happen if the board is full AND checkDraw was somehow false.
                         console.error("AI couldn't find a move but game not over/draw?");
                         if (checkDraw()) {
                             endGame("平局！");
                         } else {
                             // Fallback: Switch back to player? Or declare error?
                             updateStatus("错误: AI无法移动");
                             // Keep board disabled to indicate error state or end?
                         }
                    }

                }, 50); // Short delay before starting AI calculation
            }

            function findBestMove(depth) {
                let bestScore = -Infinity;
                let bestMove = null;
                const possibleMoves = getPossibleMoves();

                // Simple move ordering: prioritize moves closer to center or existing pieces
                possibleMoves.sort((a, b) => scoreMoveProximity(b.row, b.col) - scoreMoveProximity(a.row, a.col));

                const alpha = -Infinity;
                const beta = Infinity;

                for (const move of possibleMoves) {
                    simulatePlacePiece(move.row, move.col, WHITE); // Use simulation function
                    let score = minimax(depth - 1, false, alpha, beta);
                    simulateRemovePiece(move.row, move.col); // Use simulation function

                    // Add a small random factor to break ties, making AI less predictable
                    // score += Math.random() * 0.1; // Optional: adds slight randomness

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                     // Update alpha for the top level search as well
                     // alpha = Math.max(alpha, score); // Not strictly needed here as we check all moves

                    // Early exit if a winning move is found
                     if (bestScore >= 100000) break;
                }

                 // Fallback if no move was selected (e.g., only losing moves available)
                 if (!bestMove && possibleMoves.length > 0) {
                     bestMove = possibleMoves[0]; // Pick the 'best' proximity move
                 }

                return bestMove;
            }

            function minimax(depth, isMaximizingPlayer, alpha, beta) {
                // Check terminal states based on heuristic evaluation first
                let score = evaluateBoard();
                // If score indicates win/loss, or depth limit reached, or board full -> return score
                if (Math.abs(score) >= 100000 || depth === 0 || checkDraw()) {
                    // Adjust score slightly by depth - prefer quicker wins / later losses
                     if (score >= 100000) return score + depth; // AI wins, quicker is better
                     if (score <= -100000) return score - depth; // Player wins, later is better
                     return score; // Normal evaluation or draw
                }


                const possibleMoves = getPossibleMoves();
                 // Move ordering inside minimax can also help pruning
                 possibleMoves.sort((a, b) => scoreMoveProximity(b.row, b.col) - scoreMoveProximity(a.row, a.col));

                if (isMaximizingPlayer) { // AI's turn (WHITE) - Maximize score
                    let maxEval = -Infinity;
                    for (const move of possibleMoves) {
                        simulatePlacePiece(move.row, move.col, WHITE);
                        let evalScore = minimax(depth - 1, false, alpha, beta);
                        simulateRemovePiece(move.row, move.col);

                        maxEval = Math.max(maxEval, evalScore);
                        alpha = Math.max(alpha, evalScore);
                        if (beta <= alpha) {
                            break; // Beta cutoff
                        }
                    }
                    return maxEval;
                } else { // Player's turn (BLACK) - Minimize score
                    let minEval = Infinity;
                    for (const move of possibleMoves) {
                        simulatePlacePiece(move.row, move.col, BLACK);
                        let evalScore = minimax(depth - 1, true, alpha, beta);
                        simulateRemovePiece(move.row, move.col);

                        minEval = Math.min(minEval, evalScore);
                        beta = Math.min(beta, evalScore);
                        if (beta <= alpha) {
                            break; // Alpha cutoff
                        }
                    }
                    return minEval;
                }
            }

            function getPossibleMoves() {
                const moves = [];
                const checkRadius = 1; // Check only adjacent cells to existing pieces
                const candidates = new Set();
                let hasPieces = false;

                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] !== EMPTY) {
                            hasPieces = true;
                            // Look around this piece
                            for (let dr = -checkRadius; dr <= checkRadius; dr++) {
                                for (let dc = -checkRadius; dc <= checkRadius; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    const nr = r + dr;
                                    const nc = c + dc;
                                    // Check bounds and if the neighbour cell is empty
                                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === EMPTY) {
                                        candidates.add(`${nr}-${nc}`); // Use string key for Set uniqueness
                                    }
                                }
                            }
                        }
                    }
                }

                // If board is empty, suggest the center
                 if (!hasPieces) {
                     const center = Math.floor(BOARD_SIZE / 2);
                     return [{ row: center, col: center }];
                 }

                 // If candidates set is empty (e.g., board full, but checkDraw hasn't triggered yet), return empty array
                 if (candidates.size === 0 && hasPieces) {
                     // This might happen if checkDraw is called slightly late? Or game state issue.
                     // Scan all empty squares as a fallback, though evaluate should catch terminal state.
                      for (let r = 0; r < BOARD_SIZE; r++) {
                         for (let c = 0; c < BOARD_SIZE; c++) {
                             if (board[r][c] === EMPTY) {
                                 moves.push({ row: r, col: c });
                             }
                         }
                      }
                      return moves;
                 }

                // Convert candidate keys back to move objects
                candidates.forEach(key => {
                    const [row, col] = key.split('-').map(Number);
                    moves.push({ row, col });
                });

                return moves;
            }

            // Basic proximity scoring for move ordering
            function scoreMoveProximity(row, col) {
                 let score = 0;
                 const radius = 2; // Check within this radius
                 for (let dr = -radius; dr <= radius; dr++) {
                     for (let dc = -radius; dc <= radius; dc++) {
                         if (dr === 0 && dc === 0) continue;
                         const nr = row + dr;
                         const nc = col + dc;
                         if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] !== EMPTY) {
                              // Closer pieces get higher score (inverse manhattan distance approx)
                              score += (radius + 1) - Math.max(Math.abs(dr), Math.abs(dc));
                         }
                     }
                 }
                 // Bonus for being near center
                 const center = Math.floor(BOARD_SIZE / 2);
                 const distFromCenter = Math.max(Math.abs(row - center), Math.abs(col - center));
                 score += Math.max(0, center - distFromCenter); // Higher score closer to center

                 return score;
             }

             // --- Board Evaluation Heuristic ---
             // Returns score from AI's perspective (positive is good for AI, negative good for Player)
             function evaluateBoard() {
                 let score = 0;

                 // Score patterns - higher values for more valuable patterns
                 const scores = {
                     win: 100000,      // Five in a row
                     liveFour: 10000,   // Unblocked four
                     deadFour: 1000,    // One end blocked four
                     liveThree: 500,    // Unblocked three
                     deadThree: 50,     // One end blocked three
                     liveTwo: 10,       // Unblocked two
                     deadTwo: 2,        // One end blocked two
                     liveOne: 1         // Unblocked one (useful for tie-breaking?)
                 };

                 const directions = [
                     [0, 1], [1, 0], [1, 1], [1, -1] // horizontal, vertical, diagonal /, diagonal \
                 ];

                 // Track evaluated lines to avoid double counting (e.g., horizontal line)
                  const evaluatedLines = new Set(); // Store string like "type-r-c-dr-dc"


                 for (let r = 0; r < BOARD_SIZE; r++) {
                     for (let c = 0; c < BOARD_SIZE; c++) {
                         // No need to evaluate from empty cells
                         if (board[r][c] === EMPTY) continue;

                         const player = board[r][c];

                         for (let d = 0; d < directions.length; d++) {
                             const [dr, dc] = directions[d];

                             // Check if this specific line starting point/direction has been counted
                              let lineKey = `${d}-${r}-${c}`;
                              let backKey = `${d}-${r - dr}-${c - dc}`; // Key for the segment starting one step back

                             if (evaluatedLines.has(backKey)) continue; // Already evaluated as part of a longer line


                             let consecutive = 0;
                             let openEnds = 0;
                             let sequence = []; // Store coordinates of pieces in sequence

                             // Check "forward" including the starting piece
                              for(let i = 0; i < 5; i++) { // Check up to 5 for win condition
                                 const cr = r + dr * i;
                                 const cc = c + dc * i;
                                 if (cr >= 0 && cr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE) {
                                     if (board[cr][cc] === player) {
                                         consecutive++;
                                         sequence.push({r: cr, c: cc});
                                     } else {
                                         // If empty, it's a potential open end
                                         if (board[cr][cc] === EMPTY) {
                                             openEnds++;
                                         }
                                         break; // Stop counting consecutive on different piece or empty
                                     }
                                 } else {
                                     break; // Out of bounds
                                 }
                             }

                             // Check "backward" for the other open end
                             const br = r - dr;
                             const bc = c - dc;
                             if (br >= 0 && br < BOARD_SIZE && bc >= 0 && bc < BOARD_SIZE) {
                                 if (board[br][bc] === EMPTY) {
                                     openEnds++;
                                 }
                                 // No need to check if board[br][bc] === player, as the loop starts from each piece
                             } else {
                                 // Out of bounds counts as a blocked end implicitly
                             }


                              // --- Calculate Line Score ---
                              let lineScore = 0;
                              if (consecutive >= 5) {
                                 lineScore = scores.win;
                              } else if (consecutive === 4) {
                                 if (openEnds === 2) lineScore = scores.liveFour;
                                 else if (openEnds === 1) lineScore = scores.deadFour;
                              } else if (consecutive === 3) {
                                 if (openEnds === 2) lineScore = scores.liveThree;
                                 else if (openEnds === 1) lineScore = scores.deadThree;
                              } else if (consecutive === 2) {
                                 if (openEnds === 2) lineScore = scores.liveTwo;
                                 else if (openEnds === 1) lineScore = scores.deadTwo;
                              } else if (consecutive === 1) {
                                 if (openEnds === 2) lineScore = scores.liveOne;
                              }
                              // else consecutive is 0 or blocked - score 0


                             if (lineScore > 0) {
                                 // Add score for AI (WHITE), subtract for Player (BLACK)
                                 score += (player === WHITE) ? lineScore : -lineScore;

                                 // Mark the *end* of the evaluated sequence in this direction to prevent recounting substrings
                                 // E.g., if we found XXX, mark the line starting at the 3rd X as evaluated
                                  if (sequence.length > 0) {
                                     const lastPiece = sequence[sequence.length - 1];
                                     evaluatedLines.add(`${d}-${lastPiece.r}-${lastPiece.c}`);
                                  } else {
                                      // Should not happen if loop starts from a piece, but as safety
                                      evaluatedLines.add(lineKey);
                                  }

                             }
                         }
                     }
                 }
                 return score;
             }

            // --- Event Listeners ---

            resetBtn.addEventListener('click', initBoard);

            depthInput.addEventListener('change', () => {
                let newDepth = parseInt(depthInput.value);
                if (isNaN(newDepth) || newDepth < 1) {
                    newDepth = 1;
                    depthInput.value = newDepth;
                } else if (newDepth > 5) { // Keep reasonable max depth limit
                     newDepth = 5;
                     depthInput.value = newDepth;
                }
                aiSearchDepth = newDepth;
                console.log("AI Search Depth changed to:", aiSearchDepth);
                // Optional: You could reset the game when depth changes, or just apply it on the AI's next turn.
                // initBoard(); // Uncomment to reset game upon depth change
            });

             // Adjust board size on window resize
            window.addEventListener('resize', () => {
                 // Re-draw board only if game is active or just finished (to maintain state)
                 // Avoid re-drawing during AI thinking? Maybe okay if infrequent.
                 if (!boardElement.classList.contains('disabled') || gameOver) {
                     // Could potentially debounce this if resize events fire rapidly
                     drawBoard();
                 }
            });

            // --- Start Game ---
            initBoard(); // Initial setup
        });
    </script>
</body>
</html>
