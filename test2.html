<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>联机中国象棋</title>
  <style>
    /* 基本重置及背景 */
    body, html {
      margin: 0;
      padding: 0;
      background: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    /* 居中容器 */
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    /* 棋盘样式：模拟木质背景，并适配触摸 */
    #chessBoard {
      background: #e0cda9;
      border: 2px solid #8b4513;
      touch-action: none;
    }
    /* 状态提示 */
    #status {
      margin-top: 10px;
      font-size: 1.2em;
      color: #333;
    }
    /* 大屏幕样式 */
    @media (min-width: 600px) {
      #chessBoard {
        width: 500px;
        height: calc(500px * (10/9));
      }
    }
    /* 手机样式 */
    @media (max-width: 599px) {
      #chessBoard {
        width: 90vw;
        height: calc(90vw * (10/9));
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="chessBoard"></canvas>
    <div id="status">等待对手...</div>
  </div>

  <!-- 以下脚本使用 ES6 模块写法，包含 Firebase 初始化、棋局状态同步及棋盘绘制 -->
  <script type="module">
    // Firebase 初始化及数据库引用
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAqbA4PN7uJr_lnIRHeqvvLJQXOHHoZW4E",
      authDomain: "test-8a5cb.firebaseapp.com",
      databaseURL: "https://test-8a5cb-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "test-8a5cb",
      storageBucket: "test-8a5cb.firebasestorage.app",
      messagingSenderId: "227317352826",
      appId: "1:227317352826:web:90d96f27a4dc5d96c16ec3",
      measurementId: "G-EMJ5ZVJXBE"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getDatabase(app);

    // 全局变量
    const canvas = document.getElementById('chessBoard');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    let board = [];  // 棋盘数据：10行&times;9列
    let selected = null; // 当前选中的棋子坐标 {row, col}
    let currentTurn = "red";  // 红方先走

    // 初始化棋盘（按照中国象棋的初始布局）
    function initBoard() {
      // 创建空棋盘（10&times;9）
      board = new Array(10).fill(null).map(() => new Array(9).fill(null));

      // 黑方布局（上方）
      board[0][0] = { type: "車", side: "black" };
      board[0][1] = { type: "馬", side: "black" };
      board[0][2] = { type: "象", side: "black" };
      board[0][3] = { type: "士", side: "black" };
      board[0][4] = { type: "将", side: "black" };
      board[0][5] = { type: "士", side: "black" };
      board[0][6] = { type: "象", side: "black" };
      board[0][7] = { type: "馬", side: "black" };
      board[0][8] = { type: "車", side: "black" };
      board[2][1] = { type: "炮", side: "black" };
      board[2][7] = { type: "炮", side: "black" };
      board[3][0] = { type: "卒", side: "black" };
      board[3][2] = { type: "卒", side: "black" };
      board[3][4] = { type: "卒", side: "black" };
      board[3][6] = { type: "卒", side: "black" };
      board[3][8] = { type: "卒", side: "black" };

      // 红方布局（下方）
      board[9][0] = { type: "車", side: "red" };
      board[9][1] = { type: "馬", side: "red" };
      board[9][2] = { type: "相", side: "red" };
      board[9][3] = { type: "仕", side: "red" };
      board[9][4] = { type: "帅", side: "red" };
      board[9][5] = { type: "仕", side: "red" };
      board[9][6] = { type: "相", side: "red" };
      board[9][7] = { type: "馬", side: "red" };
      board[9][8] = { type: "車", side: "red" };
      board[7][1] = { type: "炮", side: "red" };
      board[7][7] = { type: "炮", side: "red" };
      board[6][0] = { type: "兵", side: "red" };
      board[6][2] = { type: "兵", side: "red" };
      board[6][4] = { type: "兵", side: "red" };
      board[6][6] = { type: "兵", side: "red" };
      board[6][8] = { type: "兵", side: "red" };
    }

    // 绘制棋盘网格和棋子
    function drawBoard() {
      const cw = canvas.width / 9;
      const ch = canvas.height / 10;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制网格线（横竖各 9/10 条线）
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      // 竖线
      for (let i = 0; i < 9; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cw + cw/2, ch/2);
        ctx.lineTo(i * cw + cw/2, canvas.height - ch/2);
        ctx.stroke();
      }
      // 横线
      for (let j = 0; j < 10; j++) {
        ctx.beginPath();
        ctx.moveTo(cw/2, j * ch + ch/2);
        ctx.lineTo(canvas.width - cw/2, j * ch + ch/2);
        ctx.stroke();
      }
      // 绘制棋子
      for (let i = 0; i < 10; i++) {
        for (let j = 0; j < 9; j++) {
          if (board[i][j]) {
            drawPiece(i, j, board[i][j]);
          }
        }
      }
      // 高亮选中的棋子
      if (selected) {
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 3;
        ctx.strokeRect(selected.col * cw, selected.row * ch, cw, ch);
      }
    }

    // 在 (row, col) 处绘制棋子
    function drawPiece(row, col, piece) {
      const cw = canvas.width / 9;
      const ch = canvas.height / 10;
      const x = col * cw + cw/2;
      const y = row * ch + ch/2;
      ctx.beginPath();
      ctx.arc(x, y, Math.min(cw, ch) * 0.4, 0, 2 * Math.PI);
      // 不同阵营采用不同填充色
      ctx.fillStyle = piece.side === "red" ? "#f88" : "#aaa";
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
      // 绘制棋子文字
      ctx.fillStyle = "#000";
      ctx.font = `${Math.min(cw, ch) * 0.5}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(piece.type, x, y);
    }

    // 将当前棋盘状态保存到 Firebase
    function saveBoard() {
      set(ref(db, 'game/board'), board);
      set(ref(db, 'game/turn'), currentTurn);
    }

    // 从 Firebase 加载棋盘状态
    function loadBoard() {
      const boardRef = ref(db, 'game/board');
      onValue(boardRef, (snapshot) => {
        const data = snapshot.val();
        if (data) {
          board = data;
          drawBoard();
        } else {
          // 若数据库中无数据，则初始化棋盘并保存
          initBoard();
          saveBoard();
          drawBoard();
        }
      });
      const turnRef = ref(db, 'game/turn');
      onValue(turnRef, (snapshot) => {
        const turnData = snapshot.val();
        if (turnData) {
          currentTurn = turnData;
          statusDiv.textContent = currentTurn === "red" ? "红方走棋" : "黑方走棋";
        }
      });
    }

    // 根据鼠标或触摸事件获取点击的棋盘格子
    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const col = Math.floor(x / (canvas.width / 9));
      const row = Math.floor(y / (canvas.height / 10));
      return { row, col };
    }

    // 处理点击或触摸事件
    function handleClick(e) {
      const { row, col } = getCellFromEvent(e);
      if (row < 0 || row >= 10 || col < 0 || col >= 9) return;
      // 如果未选中棋子，且点击的格子有当前方棋子则选中
      if (!selected) {
        if (board[row][col] && board[row][col].side === currentTurn) {
          selected = { row, col };
          drawBoard();
        }
      } else {
        // 如果再次点击同一格，则取消选中
        if (selected.row === row && selected.col === col) {
          selected = null;
          drawBoard();
          return;
        }
        // 如果目标格有己方棋子，则切换选中
        if (board[row][col] && board[row][col].side === currentTurn) {
          selected = { row, col };
          drawBoard();
          return;
        }
        // 否则移动棋子（此处未校验走法是否合法，可根据需要扩展规则）
        board[row][col] = board[selected.row][selected.col];
        board[selected.row][selected.col] = null;
        // 切换回合
        currentTurn = currentTurn === "red" ? "black" : "red";
        selected = null;
        saveBoard();
        drawBoard();
      }
    }

    // 响应式：窗口大小改变时调整 canvas 尺寸
    function resizeCanvas() {
      if (window.innerWidth < 600) {
        canvas.width = window.innerWidth * 0.9;
        canvas.height = canvas.width * (10/9);
      } else {
        canvas.width = 500;
        canvas.height = 500 * (10/9);
      }
      drawBoard();
    }

    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      handleClick(e);
    });

    // 初始化尺寸及加载棋局
    resizeCanvas();
    loadBoard();
  </script>
</body>
</html>
