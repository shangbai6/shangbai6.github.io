<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>在线中国象棋</title>
    <style>
        :root {
            --board-color: #f2c17d;
            --line-color: #333;
            --red-piece: #d23f42;
            --black-piece: #000;
            --highlight: rgba(0, 255, 0, 0.3);
            --possible-move: rgba(0, 0, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
            background-color: #f5f5f5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1000px;
            width: 100%;
            padding: 1rem;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        h1 {
            color: #8B4513;
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .board-container {
            position: relative;
            border: 2px solid #8B4513;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            background-color: var(--board-color);
            margin-bottom: 1rem;
        }

        .board {
            display: grid;
            position: relative;
        }

        .river {
            position: absolute;
            background-color: rgba(135, 206, 235, 0.2);
            left: 0;
            width: 100%;
            z-index: 1;
        }

        .palace {
            position: absolute;
            border: 2px dashed rgba(139, 69, 19, 0.5);
            z-index: 1;
        }

        .cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cell::before, .cell::after {
            content: "";
            position: absolute;
            background-color: var(--line-color);
        }

        .cell::before {
            width: 100%;
            height: 1px;
            top: 50%;
        }

        .cell::after {
            height: 100%;
            width: 1px;
            left: 50%;
        }

        .piece {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .piece.red {
            background-color: var(--red-piece);
            color: #fff;
        }

        .piece.black {
            background-color: var(--black-piece);
            color: #fff;
        }

        .piece.selected {
            box-shadow: 0 0 0 3px var(--highlight);
            transform: scale(1.1);
        }

        .move-indicator {
            position: absolute;
            border-radius: 50%;
            background-color: var(--possible-move);
            z-index: 5;
        }

        .game-info {
            padding: 1.5rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 350px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .player {
            text-align: center;
            padding: 0.75rem;
            border-radius: 4px;
            width: 48%;
        }

        .player.red {
            background-color: rgba(210, 63, 66, 0.1);
            color: var(--red-piece);
        }

        .player.black {
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--black-piece);
        }

        .player.active {
            box-shadow: 0 0 0 2px #4CAF50;
        }

        .game-status {
            text-align: center;
            margin: 1rem 0;
            padding: 0.75rem;
            background-color: #f9f9f9;
            border-radius: 4px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        button {
            padding: 0.75rem;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .game-id-container {
            margin-top: 1rem;
            text-align: center;
        }

        input {
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            margin: 0.5rem 0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 350px;
            width: 90%;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }

        .toast {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            z-index: 2000;
            display: none;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4CAF50;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        footer {
            margin-top: auto;
            padding: 1rem;
            text-align: center;
            width: 100%;
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>在线中国象棋</h1>
            <p>邀请好友一起对弈，随时随地畅玩中国象棋</p>
        </header>

        <div class="game-container">
            <div class="board-container" id="board-container">
                <div class="river" id="river"></div>
                <div class="palace" id="black-palace"></div>
                <div class="palace" id="red-palace"></div>
                <div class="board" id="board"></div>
                <div id="pieces-container"></div>
                <div id="move-indicators"></div>
            </div>

            <div class="game-info">
                <div class="player-info">
                    <div class="player red" id="red-player">
                        <div>红方</div>
                        <div id="red-player-name">等待加入</div>
                    </div>
                    <div class="player black" id="black-player">
                        <div>黑方</div>
                        <div id="black-player-name">等待加入</div>
                    </div>
                </div>

                <div class="game-status" id="game-status">等待开始游戏</div>

                <div class="controls">
                    <button id="create-game">创建新游戏</button>
                    <button id="join-game">加入游戏</button>
                    <button id="restart-game" disabled>重新开始</button>
                    <button id="resign" disabled>认输</button>
                </div>

                <div class="game-id-container">
                    <div>游戏ID:</div>
                    <input type="text" id="game-id" readonly>
                    <button id="copy-game-id">复制游戏ID</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="join-modal">
        <div class="modal-content">
            <h3>加入游戏</h3>
            <p>请输入游戏ID:</p>
            <input type="text" id="join-game-id" placeholder="输入游戏ID">
            <div class="modal-buttons">
                <button id="cancel-join">取消</button>
                <button id="confirm-join">加入</button>
            </div>
        </div>
    </div>

    <div class="modal" id="player-modal">
        <div class="modal-content">
            <h3>玩家信息</h3>
            <p>请输入您的昵称:</p>
            <input type="text" id="player-name" placeholder="输入昵称">
            <div class="modal-buttons">
                <button id="confirm-player">确认</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loading-text">加载中...</div>
    </div>

    <footer>
        <p>© 2025 在线中国象棋 - 优雅体验，畅快对弈</p>
    </footer>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-analytics.js";
        import { getDatabase, ref, set, onValue, update, push, get } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyAqbA4PN7uJr_lnIRHeqvvLJQXOHHoZW4E",
          authDomain: "test-8a5cb.firebaseapp.com",
          databaseURL: "https://test-8a5cb-default-rtdb.asia-southeast1.firebasedatabase.app",
          projectId: "test-8a5cb",
          storageBucket: "test-8a5cb.firebasestorage.app",
          messagingSenderId: "227317352826",
          appId: "1:227317352826:web:90d96f27a4dc5d96c16ec3",
          measurementId: "G-EMJ5ZVJXBE"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const database = getDatabase(app);

        // Game constants
        const BOARD_ROWS = 10;
        const BOARD_COLS = 9;

        // Game state
        let gameId = null;
        let playerId = null;
        let playerSide = null;
        let playerName = localStorage.getItem('playerName') || '';
        let gameState = {
            board: [],
            currentTurn: 'red',
            status: 'waiting',
            redPlayer: null,
            blackPlayer: null,
            lastMove: null
        };
        let selectedPiece = null;
        let possibleMoves = [];

        // DOM Elements
        const boardContainer = document.getElementById('board-container');
        const board = document.getElementById('board');
        const piecesContainer = document.getElementById('pieces-container');
        const moveIndicators = document.getElementById('move-indicators');
        const river = document.getElementById('river');
        const blackPalace = document.getElementById('black-palace');
        const redPalace = document.getElementById('red-palace');
        const gameStatus = document.getElementById('game-status');
        const redPlayer = document.getElementById('red-player');
        const blackPlayer = document.getElementById('black-player');
        const redPlayerName = document.getElementById('red-player-name');
        const blackPlayerName = document.getElementById('black-player-name');
        const gameIdInput = document.getElementById('game-id');
        const createGameBtn = document.getElementById('create-game');
        const joinGameBtn = document.getElementById('join-game');
        const restartGameBtn = document.getElementById('restart-game');
        const resignBtn = document.getElementById('resign');
        const copyGameIdBtn = document.getElementById('copy-game-id');
        const joinModal = document.getElementById('join-modal');
        const joinGameIdInput = document.getElementById('join-game-id');
        const confirmJoinBtn = document.getElementById('confirm-join');
        const cancelJoinBtn = document.getElementById('cancel-join');
        const playerModal = document.getElementById('player-modal');
        const playerNameInput = document.getElementById('player-name');
        const confirmPlayerBtn = document.getElementById('confirm-player');
        const toast = document.getElementById('toast');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');

        // Piece symbols
        const pieceSymbols = {
            red: {
                general: '帅',
                advisor: '仕',
                elephant: '相',
                horse: '马',
                chariot: '车',
                cannon: '炮',
                soldier: '兵'
            },
            black: {
                general: '将',
                advisor: '士',
                elephant: '象',
                horse: '马',
                chariot: '车',
                cannon: '炮',
                soldier: '卒'
            }
        };

        // Initial board setup
        const initialBoard = [
            [{ type: 'chariot', side: 'black' }, { type: 'horse', side: 'black' }, { type: 'elephant', side: 'black' }, { type: 'advisor', side: 'black' }, { type: 'general', side: 'black' }, { type: 'advisor', side: 'black' }, { type: 'elephant', side: 'black' }, { type: 'horse', side: 'black' }, { type: 'chariot', side: 'black' }],
            [null, null, null, null, null, null, null, null, null],
            [null, { type: 'cannon', side: 'black' }, null, null, null, null, null, { type: 'cannon', side: 'black' }, null],
            [{ type: 'soldier', side: 'black' }, null, { type: 'soldier', side: 'black' }, null, { type: 'soldier', side: 'black' }, null, { type: 'soldier', side: 'black' }, null, { type: 'soldier', side: 'black' }],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            [{ type: 'soldier', side: 'red' }, null, { type: 'soldier', side: 'red' }, null, { type: 'soldier', side: 'red' }, null, { type: 'soldier', side: 'red' }, null, { type: 'soldier', side: 'red' }],
            [null, { type: 'cannon', side: 'red' }, null, null, null, null, null, { type: 'cannon', side: 'red' }, null],
            [null, null, null, null, null, null, null, null, null],
            [{ type: 'chariot', side: 'red' }, { type: 'horse', side: 'red' }, { type: 'elephant', side: 'red' }, { type: 'advisor', side: 'red' }, { type: 'general', side: 'red' }, { type: 'advisor', side: 'red' }, { type: 'elephant', side: 'red' }, { type: 'horse', side: 'red' }, { type: 'chariot', side: 'red' }]
        ];

        // Dimensions
        let cellSize, pieceSize;

        // Initialize the game
        function initGame() {
            setupBoard();
            addEventListeners();
            
            // Check for saved player name
            if (!playerName) {
                showPlayerModal();
            }
            
            // Check for saved game
            const savedGameId = localStorage.getItem('gameId');
            if (savedGameId) {
                gameId = savedGameId;
                gameIdInput.value = gameId;
                joinExistingGame(gameId);
            }
            
            window.addEventListener('resize', setupBoard);
        }

        // Setup the board dimensions
        function setupBoard() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate cell size based on available space
            let maxBoardWidth = Math.min(windowWidth - 40, 500);
            if (windowWidth >= 768) {
                maxBoardWidth = Math.min(windowWidth * 0.6 - 40, 500);
            }
            
            cellSize = Math.floor(maxBoardWidth / BOARD_COLS);
            pieceSize = Math.floor(cellSize * 0.8);
            
            const boardWidth = cellSize * BOARD_COLS;
            const boardHeight = cellSize * BOARD_ROWS;
            
            // Set board dimensions
            boardContainer.style.width = `${boardWidth}px`;
            boardContainer.style.height = `${boardHeight}px`;
            board.style.width = `${boardWidth}px`;
            board.style.height = `${boardHeight}px`;
            
            // Set river position
            river.style.height = `${cellSize * 2}px`;
            river.style.top = `${cellSize * 4}px`;
            
            // Set palace positions
            blackPalace.style.width = `${cellSize * 3}px`;
            blackPalace.style.height = `${cellSize * 3}px`;
            blackPalace.style.top = 0;
            blackPalace.style.left = `${cellSize * 3}px`;
            
            redPalace.style.width = `${cellSize * 3}px`;
            redPalace.style.height = `${cellSize * 3}px`;
            redPalace.style.bottom = 0;
            redPalace.style.left = `${cellSize * 3}px`;
            
            // Draw board grid
            drawBoard();
            
            // Render pieces if game is in progress
            if (gameState.board.length > 0) {
                renderPieces();
            }
        }

        // Draw the board grid
        function drawBoard() {
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${BOARD_COLS}, ${cellSize}px)`;
            board.style.gridTemplateRows = `repeat(${BOARD_ROWS}, ${cellSize}px)`;
            
            for (let row = 0; row < BOARD_ROWS; row++) {
                for (let col = 0; col < BOARD_COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                    
                    // Add click handler for empty cells
                    cell.addEventListener('click', () => {
                        if (selectedPiece && isLegalMove(selectedPiece.row, selectedPiece.col, row, col)) {
                            makeMove(selectedPiece.row, selectedPiece.col, row, col);
                            deselectPiece();
                        }
                    });
                }
            }
        }

        // Render pieces based on the current game state
        function renderPieces() {
            piecesContainer.innerHTML = '';
            
            for (let row = 0; row < BOARD_ROWS; row++) {
                for (let col = 0; col < BOARD_COLS; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        createPieceElement(piece, row, col);
                    }
                }
            }
        }

        // Create a piece element
        function createPieceElement(piece, row, col) {
            const pieceElement = document.createElement('div');
            pieceElement.className = `piece ${piece.side}`;
            pieceElement.dataset.row = row;
            pieceElement.dataset.col = col;
            pieceElement.dataset.type = piece.type;
            pieceElement.dataset.side = piece.side;
            pieceElement.style.width = `${pieceSize}px`;
            pieceElement.style.height = `${pieceSize}px`;
            pieceElement.style.left = `${col * cellSize + (cellSize - pieceSize) / 2}px`;
            pieceElement.style.top = `${row * cellSize + (cellSize - pieceSize) / 2}px`;
            pieceElement.textContent = pieceSymbols[piece.side][piece.type];
            
            // Highlight last moved piece
            if (gameState.lastMove && gameState.lastMove.toRow === row && gameState.lastMove.toCol === col) {
                pieceElement.style.boxShadow = '0 0 8px 3px gold';
            }
            
            piecesContainer.appendChild(pieceElement);
            
            // Add click event
            pieceElement.addEventListener('click', () => handlePieceClick(row, col));
        }

        // Handle piece click
        function handlePieceClick(row, col) {
            const piece = gameState.board[row][col];
            
            // Check if it's player's turn and game is active
            if (gameState.status !== 'playing' || gameState.currentTurn !== playerSide) {
                return;
            }
            
            // If no piece is selected and clicking own piece, select it
            if (!selectedPiece && piece && piece.side === playerSide) {
                selectPiece(row, col);
                return;
            }
            
            // If piece is already selected
            if (selectedPiece) {
                // If clicking same piece, deselect it
                if (selectedPiece.row === row && selectedPiece.col === col) {
                    deselectPiece();
                    return;
                }
                
                // If clicking another own piece, select that instead
                if (piece && piece.side === playerSide) {
                    deselectPiece();
                    selectPiece(row, col);
                    return;
                }
                
                // If clicking a valid move location, make the move
                if (isLegalMove(selectedPiece.row, selectedPiece.col, row, col)) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    deselectPiece();
                }
            }
        }

        // Select a piece and show possible moves
        function selectPiece(row, col) {
            selectedPiece = { row, col };
            
            // Highlight selected piece
            const pieceElement = document.querySelector(`.piece[data-row="${row}"][data-col="${col}"]`);
            if (pieceElement) {
                pieceElement.classList.add('selected');
            }
            
            // Calculate and show possible moves
            possibleMoves = calculatePossibleMoves(row, col);
            showPossibleMoves(possibleMoves);
        }

        // Deselect the piece
        function deselectPiece() {
            if (selectedPiece) {
                const pieceElement = document.querySelector('.piece.selected');
                if (pieceElement) {
                    pieceElement.classList.remove('selected');
                }
                
                clearMoveIndicators();
                selectedPiece = null;
                possibleMoves = [];
            }
        }

        // Show possible moves
        function showPossibleMoves(moves) {
            clearMoveIndicators();
            
            moves.forEach(move => {
                const indicator = document.createElement('div');
                indicator.className = 'move-indicator';
                indicator.style.width = `${pieceSize / 2}px`;
                indicator.style.height = `${pieceSize / 2}px`;
                indicator.style.left = `${move.col * cellSize + cellSize / 2 - pieceSize / 4}px`;
                indicator.style.top = `${move.row * cellSize + cellSize / 2 - pieceSize / 4}px`;
                moveIndicators.appendChild(indicator);
            });
        }

        // Clear move indicators
        function clearMoveIndicators() {
            moveIndicators.innerHTML = '';
        }

        // Calculate possible moves for a piece
        function calculatePossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if (!piece) return [];
            
            const moves = [];
            
            switch (piece.type) {
                case 'soldier':
                    getSoldierMoves(row, col, piece.side, moves);
                    break;
                case 'cannon':
                    getCannonMoves(row, col, piece.side, moves);
                    break;
                case 'chariot':
                    getChariotMoves(row, col, piece.side, moves);
                    break;
                case 'horse':
                    getHorseMoves(row, col, piece.side, moves);
                    break;
                case 'elephant':
                    getElephantMoves(row, col, piece.side, moves);
                    break;
                case 'advisor':
                    getAdvisorMoves(row, col, piece.side, moves);
                    break;
                case 'general':
                    getGeneralMoves(row, col, piece.side, moves);
                    break;
            }
            
            // Filter out moves that would leave the general in check
            return moves.filter(move => !wouldBeInCheckAfterMove(row, col, move.row, move.col, piece.side));
        }

        // Get soldier moves
        function getSoldierMoves(row, col, side, moves) {
            const direction = side === 'red' ? -1 : 1;
            
            // Forward movement
            const newRow = row + direction;
            if (isValidPosition(newRow, col) && !isOwnPiece(newRow, col, side)) {
                moves.push({ row: newRow, col });
            }
            
            // Side movement (only after crossing the river)
            const hasCrossedRiver = (side === 'red' && row < 5) || (side === 'black' && row > 4);
            if (hasCrossedRiver) {
                // Left
                if (isValidPosition(row, col - 1) && !isOwnPiece(row, col - 1, side)) {
                    moves.push({ row, col: col - 1 });
                }
                
                // Right
                if (isValidPosition(row, col + 1) && !isOwnPiece(row, col + 1, side)) {
                    moves.push({ row, col: col + 1 });
                }
            }
        }

        // Get cannon moves
        function getCannonMoves(row, col, side, moves) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
            
            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                
                // First part: move without capturing
                while (isValidPosition(r, c) && !gameState.board[r][c]) {
                    moves.push({ row: r, col: c });
                    r += dr;
                    c += dc;
                }
                
                // Found a potential platform to jump over
                if (isValidPosition(r, c)) {
                    r += dr;
                    c += dc;
                    
                    // Continue until finding a piece to capture
                    while (isValidPosition(r, c)) {
                        if (gameState.board[r][c]) {
                            if (gameState.board[r][c].side !== side) {
                                moves.push({ row: r, col: c });
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                }
            }
        }

        // Get chariot moves
        function getChariotMoves(row, col, side, moves) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
            
            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                
                while (isValidPosition(r, c)) {
                    if (!gameState.board[r][c]) {
                        moves.push({ row: r, col: c });
                    } else {
                        if (gameState.board[r][c].side !== side) {
                            moves.push({ row: r, col: c });
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            }
        }

        // Get horse moves
        function getHorseMoves(row, col, side, moves) {
            const possibleMoves = [
                { dr: -2, dc: -1, blockDr: -1, blockDc: 0 }, // Up-left
                { dr: -2, dc: 1, blockDr: -1, blockDc: 0 },  // Up-right
                { dr: -1, dc: -2, blockDr: 0, blockDc: -1 }, // Left-up
                { dr: -1, dc: 2, blockDr: 0, blockDc: 1 },   // Right-up
                { dr: 1, dc: -2, blockDr: 0, blockDc: -1 },  // Left-down
                { dr: 1, dc: 2, blockDr: 0, blockDc: 1 },    // Right-down
                { dr: 2, dc: -1, blockDr: 1, blockDc: 0 },   // Down-left
                { dr: 2, dc: 1, blockDr: 1, blockDc: 0 }     // Down-right
            ];
            
            for (const move of possibleMoves) {
                const r = row + move.dr;
                const c = col + move.dc;
                
                if (isValidPosition(r, c) && !isOwnPiece(r, c, side)) {
                    // Check if horse's leg is blocked
                    const blockRow = row + move.blockDr;
                    const blockCol = col + move.blockDc;
                    
                    if (!gameState.board[blockRow][blockCol]) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
        }

        // Get elephant moves
        function getElephantMoves(row, col, side, moves) {
            const possibleMoves = [
                { dr: -2, dc: -2, blockDr: -1, blockDc: -1 }, // Up-left
                { dr: -2, dc: 2, blockDr: -1, blockDc: 1 },   // Up-right
                { dr: 2, dc: -2, blockDr: 1, blockDc: -1 },   // Down-left
                { dr: 2, dc: 2, blockDr: 1, blockDc: 1 }      // Down-right
            ];
            
            for (const move of possibleMoves) {
                const r = row + move.dr;
                const c = col + move.dc;
                
                if (isValidPosition(r, c) && !isOwnPiece(r, c, side) && !isCrossingRiver(r, side)) {
                    // Check if elephant's eye is blocked
                    const blockRow = row + move.blockDr;
                    const blockCol = col + move.blockDc;
                    
                    if (!gameState.board[blockRow][blockCol]) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
        }

        // Get advisor moves
        function getAdvisorMoves(row, col, side, moves) {
            const possibleMoves = [
                { dr: -1, dc: -1 }, // Up-left
                { dr: -1, dc: 1 },  // Up-right
                { dr: 1, dc: -1 },  // Down-left
                { dr: 1, dc: 1 }    // Down-right
            ];
            
            for (const move of possibleMoves) {
                const r = row + move.dr;
                const c = col + move.dc;
                
                if (isValidPosition(r, c) && isInPalace(r, c, side) && !isOwnPiece(r, c, side)) {
                    moves.push({ row: r, col: c });
                }
            }
        }

        // Get general moves
        function getGeneralMoves(row, col, side, moves) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
            
            for (const [dr, dc] of directions) {
                const r = row + dr;
                const c = col + dc;
                
                if (isValidPosition(r, c) && isInPalace(r, c, side) && !isOwnPiece(r, c, side)) {
                    moves.push({ row: r, col: c });
                }
            }
            
            // Flying general rule
            const opposingSide = side === 'red' ? 'black' : 'red';
            const opposingGeneral = findGeneral(opposingSide);
            
            if (opposingGeneral && opposingGeneral.col === col) {
                // Check if there are no pieces between generals
                let hasPieceBetween = false;
                const startRow = Math.min(row, opposingGeneral.row);
                const endRow = Math.max(row, opposingGeneral.row);
                
                for (let r = startRow + 1; r < endRow; r++) {
                    if (gameState.board[r][col]) {
                        hasPieceBetween = true;
                        break;
                    }
                }
                
                if (!hasPieceBetween) {
                    moves.push({ row: opposingGeneral.row, col });
                }
            }
        }

        // Find general position
        function findGeneral(side) {
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece.type === 'general' && piece.side === side) {
                        return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        // Check if a position is valid
        function isValidPosition(row, col) {
            return row >= 0 && row < BOARD_ROWS && col >= 0 && col < BOARD_COLS;
        }

        // Check if a position contains own piece
        function isOwnPiece(row, col, side) {
            return gameState.board[row][col] && gameState.board[row][col].side === side;
        }

        // Check if position is crossing the river for elephant
        function isCrossingRiver(row, side) {
            return (side === 'red' && row < 5) || (side === 'black' && row > 4);
        }

        // Check if position is in palace
        function isInPalace(row, col, side) {
            if (side === 'red') {
                return row >= 7 && row <= 9 && col >= 3 && col <= 5;
            } else {
                return row >= 0 && row <= 2 && col >= 3 && col <= 5;
            }
        }

        // Check if a move is legal
        function isLegalMove(fromRow, fromCol, toRow, toCol) {
            if (!selectedPiece) return false;
            
            return possibleMoves.some(move => move.row === toRow && move.col === toCol);
        }

        // Check if a move would leave the player in check
        function wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, side) {
            // Make a temporary copy of the board
            const tempBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // Make the move on the temporary board
            tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
            tempBoard[fromRow][fromCol] = null;
            
            // Check if the general would be in check
            const generalPos = findGeneralOnBoard(tempBoard, side);
            if (!generalPos) return false;
            
            // Check if any opponent piece can capture the general
            const opposingSide = side === 'red' ? 'black' : 'red';
            
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const piece = tempBoard[r][c];
                    if (piece && piece.side === opposingSide) {
                        if (canPieceCaptureGeneral(tempBoard, r, c, generalPos.row, generalPos.col)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Find general on a board
        function findGeneralOnBoard(board, side) {
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === 'general' && piece.side === side) {
                        return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        // Check if a piece can capture the general
        function canPieceCaptureGeneral(board, fromRow, fromCol, generalRow, generalCol) {
            // This is a simplified implementation for checking check
            // In a full implementation, you would need to check for each piece type
            
            // For now, always return false to simplify the example
            return false;
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const updatedBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // Store moving piece and capture info
            const movingPiece = updatedBoard[fromRow][fromCol];
            const capturedPiece = updatedBoard[toRow][toCol];
            
            // Make the move
            updatedBoard[toRow][toCol] = movingPiece;
            updatedBoard[fromRow][fromCol] = null;
            
            // Record last move
            const lastMove = {
                fromRow,
                fromCol,
                toRow,
                toCol,
                piece: movingPiece,
                captured: capturedPiece
            };
            
            // Switch turns
            const nextTurn = gameState.currentTurn === 'red' ? 'black' : 'red';
            
            // Update game in Firebase
            update(ref(database, `games/${gameId}`), {
                board: updatedBoard,
                currentTurn: nextTurn,
                lastMove: lastMove
            }).catch(error => {
                console.error("Error updating game:", error);
                showToast("无法更新游戏状态");
            });
            
            // Check if game is over (general captured)
            if (capturedPiece && capturedPiece.type === 'general') {
                endGame(`${movingPiece.side === 'red' ? '红方' : '黑方'}获胜！`);
            }
        }

        // Add event listeners
        function addEventListeners() {
            createGameBtn.addEventListener('click', createNewGame);
            joinGameBtn.addEventListener('click', () => showModal(joinModal));
            restartGameBtn.addEventListener('click', restartGame);
            resignBtn.addEventListener('click', resignGame);
            copyGameIdBtn.addEventListener('click', copyGameId);
            confirmJoinBtn.addEventListener('click', () => {
                const id = joinGameIdInput.value.trim();
                if (id) {
                    hideModal(joinModal);
                    joinExistingGame(id);
                } else {
                    showToast("请输入有效的游戏ID");
                }
            });
            cancelJoinBtn.addEventListener('click', () => hideModal(joinModal));
            confirmPlayerBtn.addEventListener('click', () => {
                const name = playerNameInput.value.trim();
                if (name) {
                    playerName = name;
                    localStorage.setItem('playerName', name);
                    hideModal(playerModal);
                } else {
                    showToast("请输入昵称");
                }
            });
        }

        // Create a new game
        function createNewGame() {
            if (!playerName) {
                showModal(playerModal);
                return;
            }
            
            showLoading("创建新游戏...");
            
            // Create a new game in Firebase
            const newGameRef = push(ref(database, 'games'));
            gameId = newGameRef.key;
            
            // Set player as red
            playerSide = 'red';
            playerId = generatePlayerId();
            
            // Create initial game state
            const newGameState = {
                board: initialBoard,
                currentTurn: 'red',
                status: 'waiting',
                redPlayer: {
                    id: playerId,
                    name: playerName
                },
                blackPlayer: null,
                created: Date.now()
            };
            
            // Save to Firebase
            set(newGameRef, newGameState)
                .then(() => {
                    // Update UI
                    gameIdInput.value = gameId;
                    redPlayerName.textContent = playerName;
                    blackPlayerName.textContent = "等待加入";
                    gameStatus.textContent = "等待对手加入...";
                    
                    // Save to local storage
                    localStorage.setItem('gameId', gameId);
                    localStorage.setItem('playerId', playerId);
                    localStorage.setItem('playerSide', playerSide);
                    
                    hideLoading();
                    showToast("游戏创建成功！分享ID邀请对手");
                    
                    // Setup listener for game changes
                    setupGameListener();
                })
                .catch(error => {
                    console.error("Error creating game:", error);
                    hideLoading();
                    showToast("创建游戏失败，请重试");
                });
        }

        // Join an existing game
        function joinExistingGame(gameIdToJoin) {
            if (!playerName) {
                showModal(playerModal);
                return;
            }
            
            showLoading("加入游戏...");
            
            // Check if game exists
            get(ref(database, `games/${gameIdToJoin}`))
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        hideLoading();
                        showToast("游戏不存在，请检查ID");
                        return;
                    }
                    
                    const gameData = snapshot.val();
                    
                    // Check if player is already in this game
                    const savedPlayerId = localStorage.getItem('playerId');
                    const savedPlayerSide = localStorage.getItem('playerSide');
                    
                    // Rejoin as same player if already in game
                    if (savedPlayerId && savedPlayerSide && 
                        ((savedPlayerSide === 'red' && gameData.redPlayer && gameData.redPlayer.id === savedPlayerId) || 
                         (savedPlayerSide === 'black' && gameData.blackPlayer && gameData.blackPlayer.id === savedPlayerId))) {
                        
                        gameId = gameIdToJoin;
                        playerId = savedPlayerId;
                        playerSide = savedPlayerSide;
                        
                        gameIdInput.value = gameId;
                        setupGameListener();
                        hideLoading();
                        showToast("重新连接到游戏");
                        return;
                    }
                    
                    // Check if game is full
                    if (gameData.redPlayer && gameData.blackPlayer) {
                        hideLoading();
                        showToast("游戏已满，无法加入");
                        return;
                    }
                    
                    // Determine which side to join
                    if (!gameData.redPlayer) {
                        playerSide = 'red';
                    } else if (!gameData.blackPlayer) {
                        playerSide = 'black';
                    } else {
                        hideLoading();
                        showToast("游戏已满，无法加入");
                        return;
                    }
                    
                    // Generate player ID
                    playerId = generatePlayerId();
                    
                    // Update game with new player
                    const updates = {};
                    updates[`${playerSide}Player`] = {
                        id: playerId,
                        name: playerName
                    };
                    
                    // If both players are now present, update game status
                    if ((playerSide === 'red' && gameData.blackPlayer) || 
                        (playerSide === 'black' && gameData.redPlayer)) {
                        updates.status = 'playing';
                    }
                    
                    // Update Firebase
                    update(ref(database, `games/${gameIdToJoin}`), updates)
                        .then(() => {
                            gameId = gameIdToJoin;
                            gameIdInput.value = gameId;
                            
                            // Save to local storage
                            localStorage.setItem('gameId', gameId);
                            localStorage.setItem('playerId', playerId);
                            localStorage.setItem('playerSide', playerSide);
                            
                            setupGameListener();
                            hideLoading();
                            showToast("成功加入游戏");
                        })
                        .catch(error => {
                            console.error("Error joining game:", error);
                            hideLoading();
                            showToast("加入游戏失败，请重试");
                        });
                })
                .catch(error => {
                    console.error("Error checking game:", error);
                    hideLoading();
                    showToast("验证游戏ID失败，请重试");
                });
        }

        // Set up listener for game changes
        function setupGameListener() {
            onValue(ref(database, `games/${gameId}`), snapshot => {
                if (!snapshot.exists()) {
                    showToast("游戏不存在或已被删除");
                    resetGame();
                    return;
                }
                
                const data = snapshot.val();
                gameState = data;
                
                updateGameUI();
                renderPieces();
            });
        }

        // Update game UI based on state
        function updateGameUI() {
            // Update player names
            if (gameState.redPlayer) {
                redPlayerName.textContent = gameState.redPlayer.name;
            } else {
                redPlayerName.textContent = "等待加入";
            }
            
            if (gameState.blackPlayer) {
                blackPlayerName.textContent = gameState.blackPlayer.name;
            } else {
                blackPlayerName.textContent = "等待加入";
            }
            
            // Update active player highlighting
            if (gameState.currentTurn === 'red') {
                redPlayer.classList.add('active');
                blackPlayer.classList.remove('active');
            } else {
                redPlayer.classList.remove('active');
                blackPlayer.classList.add('active');
            }
            
            // Update game status
            if (gameState.status === 'waiting') {
                gameStatus.textContent = "等待对手加入...";
                resignBtn.disabled = true;
                restartGameBtn.disabled = true;
            } else if (gameState.status === 'playing') {
                if (gameState.currentTurn === playerSide) {
                    gameStatus.textContent = "轮到你走棋";
                } else {
                    gameStatus.textContent = "等待对手走棋";
                }
                resignBtn.disabled = false;
                restartGameBtn.disabled = false;
            } else if (gameState.status === 'completed') {
                gameStatus.textContent = gameState.result || "游戏结束";
                resignBtn.disabled = true;
                restartGameBtn.disabled = false;
            }
        }

        // Restart the game
        function restartGame() {
            if (!gameId) return;
            
            update(ref(database, `games/${gameId}`), {
                board: initialBoard,
                currentTurn: 'red',
                status: 'playing',
                lastMove: null
            }).catch(error => {
                console.error("Error restarting game:", error);
                showToast("重启游戏失败");
            });
        }

        // Resign from the game
        function resignGame() {
            if (!gameId || gameState.status !== 'playing') return;
            
            const winner = playerSide === 'red' ? 'black' : 'red';
            const result = playerSide === 'red' ? '红方认输，黑方获胜！' : '黑方认输，红方获胜！';
            
            update(ref(database, `games/${gameId}`), {
                status: 'completed',
                result: result,
                winner: winner
            }).catch(error => {
                console.error("Error resigning:", error);
                showToast("认输操作失败");
            });
        }

        // End the game
        function endGame(result) {
            if (!gameId) return;
            
            update(ref(database, `games/${gameId}`), {
                status: 'completed',
                result: result,
                winner: result.includes('红方') ? 'red' : 'black'
            }).catch(error => {
                console.error("Error ending game:", error);
                showToast("结束游戏失败");
            });
        }

        // Reset the game state
        function resetGame() {
            gameId = null;
            playerId = null;
            playerSide = null;
            gameState = {
                board: [],
                currentTurn: 'red',
                status: 'waiting',
                redPlayer: null,
                blackPlayer: null,
                lastMove: null
            };
            
            // Reset UI
            gameIdInput.value = "";
            redPlayerName.textContent = "等待加入";
            blackPlayerName.textContent = "等待加入";
            gameStatus.textContent = "等待开始游戏";
            piecesContainer.innerHTML = "";
            moveIndicators.innerHTML = "";
            
            // Reset buttons
            resignBtn.disabled = true;
            restartGameBtn.disabled = true;
            
            // Clear local storage
            localStorage.removeItem('gameId');
            localStorage.removeItem('playerId');
            localStorage.removeItem('playerSide');
        }

        // Copy game ID to clipboard
        function copyGameId() {
            if (!gameId) return;
            
            navigator.clipboard.writeText(gameId)
                .then(() => {
                    showToast("游戏ID已复制到剪贴板");
                })
                .catch(error => {
                    console.error("Copy failed:", error);
                    showToast("复制失败，请手动复制");
                });
        }

        // Show modal
        function showModal(modal) {
            modal.style.display = 'flex';
        }

        // Hide modal
        function hideModal(modal) {
            modal.style.display = 'none';
        }

        // Show player modal
        function showPlayerModal() {
            playerNameInput.value = playerName || '';
            showModal(playerModal);
        }

        // Show toast message
        function showToast(message) {
            toast.textContent = message;
            toast.style.display = 'block';
            
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }

        // Show loading spinner
        function showLoading(message) {
            loadingText.textContent = message || "加载中...";
            loading.style.display = 'flex';
        }

        // Hide loading spinner
        function hideLoading() {
            loading.style.display = 'none';
        }

        // Generate unique player ID
        function generatePlayerId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
